# let 和 const 命令  

let 命令
基本用法
ES6 新增了 let 命令， 用来声明变量。 它的用法类似于 var ， 但是所声明的变
量， 只在 let 命令所在的代码块内有效。

```{
let a = 10;
var b = 1;
} a
// ReferenceError: a is not defined.
b // 1  ```
```

上面代码在代码块之中， 分别用 let 和 var 声明了两个变量。 然后在代码块之外
调用这两个变量， 结果 let 声明的变量报错， var 声明的变量返回了正确的值。
这表明， let 声明的变量只在它所在的代码块有效。  

 ```var a = [];
 ```for (var i = 0; i < 10; i++) {
a[i] = function () {
console.log(i);
};
} a
[6](); // 10 ```


上面代码中， 变量 i 是 var 命令声明的， 在全局范围内都有效， 所以全局只有一
个变量 i 。 每一次循环， 变量 i 的值都会发生改变， 而循环内被赋给数组 a 的
函数内部的 console.log(i) ， 里面的 i 指向的就是全局的 i 。 也就是说， 所
有数组 a 的成员里面的 i ， 指向的都是同一个 i ， 导致运行时输出的是最后一
轮的 i 的值， 也就是10。
如果使用 let ， 声明的变量仅在块级作用域内有效， 最后输出的是6。
 ```



 ```var a = [];
for (let i = 0; i < 10; i++) {
a[i] = function () {
console.log(i);
};
} a
[6](); // 6 ```
 ```



上面代码中， 变量 i 是 let 声明的， 当前的 i 只在本轮循环有效， 所以每一次
循环的 i 其实都是一个新的变量， 所以最后输出的是 6 。 你可能会问， 如果每一
轮循环的变量 i 都是重新声明的， 那它怎么知道上一轮循环的值， 从而计算出本
轮循环的值？ 这是因为 JavaScript 引擎内部会记住上一轮循环的值， 初始化本轮的
变量 i 时， 就在上一轮循环的基础上进行计算。
另外， for 循环还有一个特别之处， 就是设置循环变量的那部分是一个父作用**
域， 而循环体内部是一个单独的子作用域。**  

### 不存在变量提升  

### 暂时性死区  

总之， 在代码块内， 使用 let 命令声明变量之前， 该变量都是不可用的。 这在语
法上， 称为“暂时性死区”（ temporal dead zone， 简称 TDZ） 。  

```var tmp = 123;
if (true) {
tmp = 'abc'; // ReferenceError
let tmp;
}  ```
```

### 不允许重复声明  





## 块级作用域

为什么需要块级作用域？
ES5 只有全局作用域和函数作用域， 没有块级作用域， 这带来很多不合理的场景。
第一种场景， 内层变量可能会覆盖外层变量。 


let 实际上为 JavaScript 新增了块级作用域。

ES6 允许块级作用域的任意嵌套。 





块级作用域的出现， 实际上使得获得广泛应用的立即执行函数表达式（ IIFE） 不再
必要了。

```// IIFE 写法
(function () {
var tmp = ...;
...
}());
// 块级作用域写法
{
let tmp = ...;
...
}  ```   
```

### 块级作用域与函数声明  

ES6 引入了块级作用域， 明确允许在块级作用域之中声明函数。 ES6 规定， 块级作
用域之中， 函数声明语句的行为类似于 let ， 在块级作用域之外不可引用。  



根据这三条规则， 在浏览器的 ES6 环境中， 块级作用域内声明的函数， 行为类似
于 var 声明的变量。  



考虑到环境导致的行为差异太大， 应该避免在块级作用域内声明函数。 如果确实需
要， 也应该写成函数表达式， 而不是函数声明语句。  

### do 表达式

本质上， 块级作用域是一个语句， 将多个操作封装在一起， 没有返回值。
let 和 const 命令
37

```{
let t = f();
t = t * t + 1;
}```
```

上面代码中， 块级作用域将两个语句封装在一起。 但是， 在块级作用域以外， 没有
办法得到 t 的值， 因为块级作用域不返回值， 除非 t 是全局变量。
现在有一个提案， 使得块级作用域可以变为表达式， 也就是说可以返回值， 办法就
是在块级作用域之前加上 do ， 使它变为 do 表达式。

```let x = do {
let t = f();
t * t + 1;
};```
```

上面代码中， 变量 x 会得到整个块级作用域的返回值。  

## const 命令

基本用法
const 声明一个只读的常量。 一旦声明， 常量的值就不能改变  

const 实际上保证的， 并不是变量的值不得改动， 而是变量指向的那个内存地址
不得改动。 对于简单类型的数据（ 数值、 字符串、 布尔值） ， 值就保存在变量指向
的那个内存地址， 因此等同于常量  